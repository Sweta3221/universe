<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Universal Galaxy Experience</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            touch-action: none; /* Prevent browser from handling touch gestures */
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        const galaxies = [];
        let backgroundStars;
        const cosmicDustLayers = [];

        // --- GLOBAL SIMULATION PARAMETERS (Balanced for Laptop and Mobile) ---
        const numberOfGalaxies = 7; // Slightly increased from mobile, balanced
        const sceneExtent = 8000;
        const galaxyDistributionPadding = 1500;

        // --- GALAXY TEMPLATE PARAMETERS (Balanced for Laptop and Mobile) ---
        const defaultParticleCount = 4000; // Increased for better laptop visuals, but not too high for mobile
        const defaultGalaxyRadius = 300;
        const defaultArmCount = 4;
        const defaultArmSpread = 0.1;
        const defaultArmTwist = 2.0;
        const defaultCoreSize = 30;

        const defaultSpiralTightness = 1.8;
        const defaultArmOffset = 0.5;
        const defaultThickness = 0.05;

        const defaultBlackHoleRadius = 10;
        const defaultBlackHoleInfluenceRadius = 50;
        const defaultDevouringSpeed = 0.01;
        const defaultDevouringProbability = 0.005;
        const defaultMaxDevouringStars = 30;

        const diskPulseSpeed = 0.05;
        const diskPulseAmount = 0.2;
        const diskRotationSpeed = 0.005;
        // --- END GALAXY TEMPLATE PARAMETERS ---

        // --- BACKGROUND PARAMETERS (Balanced for Laptop and Mobile) ---
        const backgroundStarCount = 200000; // Increased for better laptop background, still manageable for mobile
        const backgroundStarFieldSize = 20000;
        const backgroundStarMinSize = 0.5;
        const backgroundStarMaxSize = 2.0;
        const backgroundStarTwinkleSpeed = 0.005;

        const nebulaLayersData = [
            { radius: 10000, color: 0x110033, opacity: 0.05, rotationSpeed: 0.00005 },
            { radius: 12000, color: 0x001133, opacity: 0.04, rotationSpeed: 0.00003 },
            { radius: 15000, color: 0x002222, opacity: 0.02, rotationSpeed: 0.00002 },
            { radius: 18000, color: 0x001111, opacity: 0.01, rotationSpeed: 0.00001 } // Added back a layer
        ];
        // --- END BACKGROUND PARAMETERS ---


        // --- Galaxy Class/Constructor ---
        function Galaxy(options = {}) {
            this.id = Math.random().toString(36).substring(7);
            this.position = options.position || new THREE.Vector3(0, 0, 0);

            this.particleCount = options.particleCount || defaultParticleCount;
            this.galaxyRadius = options.galaxyRadius || defaultGalaxyRadius;
            this.armCount = options.armCount || defaultArmCount;
            this.armSpread = options.armSpread || defaultArmSpread;
            this.armTwist = options.armTwist || defaultArmTwist;
            this.coreSize = options.coreSize || defaultCoreSize;

            this.spiralTightness = options.spiralTightness || defaultSpiralTightness;
            this.armOffset = options.armOffset || defaultArmOffset;
            this.thickness = options.thickness || defaultThickness;

            this.blackHoleRadius = options.blackHoleRadius || defaultBlackHoleRadius;
            this.blackHoleInfluenceRadius = options.blackHoleInfluenceRadius || defaultBlackHoleInfluenceRadius;
            this.devouringSpeed = options.devouringSpeed || defaultDevouringSpeed;
            this.devouringProbability = options.devouringProbability || defaultDevouringProbability;
            this.maxDevouringStars = options.maxDevouringStars || defaultMaxDevouringStars;

            this.devouringStars = [];

            this.colorCentral = options.colorCentral || new THREE.Color(0xFFEEAA);
            this.colorOuter = options.colorOuter || new THREE.Color(0x88CCFF);
            this.diskColor = options.diskColor || new THREE.Color(0xFF5500);

            this.rotationSpeed = options.rotationSpeed || 0.0005;

            this.group = new THREE.Group();
            this.group.position.copy(this.position);

            this.particles = null;
            this.blackHole = null;
            this.accretionDisk = null;
            this.blackHoleLight = null;
            this.diskTimer = Math.random() * Math.PI * 2;

            this.init = function() {
                this.createGalaxyParticles();
                this.createBlackHoleAndDisk();
                scene.add(this.group);
            };

            this.createGalaxyParticles = function() {
                const positions = new Float32Array(this.particleCount * 3);
                const colors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);

                for (let i = 0; i < this.particleCount; i++) {
                    const armIndex = i % this.armCount;
                    const armRotation = armIndex * (Math.PI * 2 / this.armCount);

                    let distance = Math.pow(Math.random(), 3) * this.galaxyRadius;
                    const angle = distance * this.spiralTightness + armRotation + (Math.random() - 0.5) * this.armOffset;

                    let x = distance * Math.cos(angle);
                    let z = distance * Math.sin(angle);
                    let y = (Math.random() - 0.5) * distance * this.thickness;

                    if (distance < this.coreSize) {
                        const bulgeFactor = (this.coreSize - distance) / this.coreSize;
                        y += (Math.random() - 0.5) * bulgeFactor * this.coreSize * 0.7;
                        x += (Math.random() - 0.5) * bulgeFactor * this.coreSize * 0.3;
                        z += (Math.random() - 0.5) * bulgeFactor * this.coreSize * 0.3;
                    }

                    x += (Math.random() - 0.5) * 5;
                    y += (Math.random() - 0.5) * 5;
                    z += (Math.random() - 0.5) * 5;

                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    const t = distance / this.galaxyRadius;
                    const interpolatedColor = new THREE.Color().copy(this.colorCentral).lerp(this.colorOuter, t);
                    colors[i * 3] = interpolatedColor.r;
                    colors[i * 3 + 1] = interpolatedColor.g;
                    colors[i * 3 + 2] = interpolatedColor.b;

                    sizes[i] = (Math.random() * 0.8 + 0.2) * 2;
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(0xffffff) },
                        pointTexture: { value: new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/examples/textures/sprites/disc.png') },
                        cameraNear: { value: camera.near },
                        cameraFar: { value: camera.far }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        varying vec3 vColor;
                        varying float vVisibility;
                        uniform float cameraNear;
                        uniform float cameraFar;

                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                            
                            // Adjust point size for varying DPI
                            float pointSize = size * ( 300.0 / -mvPosition.z ); // Base size for laptops
                            gl_PointSize = max(1.5, min(pointSize, 10.0)); // Ensure min size for visibility, clamp max
                            
                            gl_Position = projectionMatrix * mvPosition;

                            float distFromNear = -mvPosition.z - cameraNear;
                            float fadeStartDistance = 20.0;
                            float fadeEndDistance = 0.0;
                            vVisibility = smoothstep(fadeEndDistance, fadeStartDistance, distFromNear);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 color;
                        uniform sampler2D pointTexture;
                        varying vec3 vColor;
                        varying float vVisibility;

                        void main() {
                            gl_FragColor = vec4( vColor, vVisibility ) * texture2D( pointTexture, gl_PointCoord );
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                });

                this.particles = new THREE.Points(geometry, material);
                this.group.add(this.particles);
            };

            this.createBlackHoleAndDisk = function() {
                const bhGeometry = new THREE.SphereGeometry(this.blackHoleRadius, 32, 32); // Balanced segments
                const bhMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.8
                });
                this.blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
                this.group.add(this.blackHole);

                const diskInnerRadius = this.blackHoleRadius * 1.1;
                const diskOuterRadius = this.blackHoleRadius * 3;
                const diskThickness = 2;

                const diskGeometry = new THREE.TorusGeometry(
                    diskInnerRadius,
                    diskThickness / 2,
                    12, // Balanced radial segments
                    60, // Balanced tubular segments
                    Math.PI * 2
                );
                this.accretionDisk = new THREE.Mesh(diskGeometry, new THREE.MeshBasicMaterial({
                    color: this.diskColor,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                }));
                this.accretionDisk.rotation.x = Math.PI / 2;
                this.group.add(this.accretionDisk);

                this.blackHoleLight = new THREE.PointLight(this.diskColor, 15, this.blackHoleRadius * 2);
                this.group.add(this.blackHoleLight);
            };

            this.update = function() {
                this.group.rotation.y += this.rotationSpeed;

                this.diskTimer += diskPulseSpeed;
                const pulseScale = 1.0 + Math.sin(this.diskTimer) * diskPulseAmount;
                this.accretionDisk.scale.set(pulseScale, pulseScale, pulseScale);
                this.accretionDisk.material.opacity = 0.5 + (Math.sin(this.diskTimer * 0.5) * 0.2);
                this.accretionDisk.rotation.z += diskRotationSpeed;

                this.devourStars();
            };

            this.devourStars = function() {
                const positionsAttribute = this.particles.geometry.attributes.position;
                const currentPositions = positionsAttribute.array;

                for (let i = this.devouringStars.length - 1; i >= 0; i--) {
                    const starIndex = this.devouringStars[i];
                    const px = currentPositions[starIndex * 3];
                    const py = currentPositions[starIndex * 3 + 1];
                    const pz = currentPositions[starIndex * 3 + 2];

                    const direction = new THREE.Vector3(-px, -py, -pz).normalize();
                    const currentDistance = new THREE.Vector3(px, py, pz).length();

                    if (currentDistance > this.blackHoleRadius * 0.5) {
                        currentPositions[starIndex * 3] += direction.x * this.devouringSpeed * currentDistance;
                        currentPositions[starIndex * 3 + 1] += direction.y * this.devouringSpeed * currentDistance;
                        currentPositions[starIndex * 3 + 2] += direction.z * this.devouringSpeed * currentDistance;
                    } else {
                        this.resetDevouredStar(starIndex);
                        this.devouringStars.splice(i, 1);
                    }
                }

                if (this.devouringStars.length < this.maxDevouringStars) {
                    for (let i = 0; i < this.particleCount; i += Math.floor(this.particleCount / (this.maxDevouringStars * 5))) {
                        if (this.devouringStars.includes(i)) continue;

                        const px = currentPositions[i * 3];
                        const py = currentPositions[i * 3 + 1];
                        const pz = currentPositions[i * 3 + 2];

                        const distanceToCenter = new THREE.Vector3(px, py, pz).length();

                        if (distanceToCenter < this.blackHoleInfluenceRadius && Math.random() < this.devouringProbability) {
                            this.devouringStars.push(i);
                            if (this.devouringStars.length >= this.maxDevouringStars) break;
                        }
                    }
                }
                positionsAttribute.needsUpdate = true;
            };

            this.resetDevouredStar = function(index) {
                const armIndex = Math.floor(Math.random() * this.armCount);
                const armRotation = armIndex * (Math.PI * 2 / this.armCount);
                let distance = Math.pow(Math.random(), 3) * this.galaxyRadius;
                const angle = distance * this.spiralTightness + armRotation + (Math.random() - 0.5) * this.armOffset;

                let x = distance * Math.cos(angle);
                let z = distance * Math.sin(angle);
                let y = (Math.random() - 0.5) * distance * this.thickness;

                if (distance < this.coreSize) {
                    const bulgeFactor = (this.coreSize - distance) / this.coreSize;
                    y += (Math.random() - 0.5) * bulgeFactor * this.coreSize * 0.7;
                    x += (Math.random() - 0.5) * bulgeFactor * this.coreSize * 0.3;
                    z += (Math.random() - 0.5) * bulgeFactor * this.coreSize * 0.3;
                }

                x += (Math.random() - 0.5) * 5;
                y += (Math.random() - 0.5) * 5;
                z += (Math.random() - 0.5) * 5;

                const positionsAttribute = this.particles.geometry.attributes.position;
                const currentPositions = positionsAttribute.array;

                currentPositions[index * 3] = x;
                currentPositions[index * 3 + 1] = y;
                currentPositions[index * 3 + 2] = z;
            };
        }
        // --- End Galaxy Class/Constructor ---


        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.00002); // Standard fog

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 30000); // Back to larger far clip
            camera.position.set(0, sceneExtent * 0.9, sceneExtent * 2.5); // Initial position as before
            camera.lookAt(0,0,0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: 'high-performance'
            });
            // CRITICAL CHANGE FOR LAPTOP VISIBILITY:
            renderer.setPixelRatio(window.devicePixelRatio); // Use device's pixel ratio (default for Three.js, good for laptops)
            // You can adjust this for performance: `Math.min(2, window.devicePixelRatio)` or `1.5`
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05; // Standard damping
            controls.minDistance = 10;
            controls.maxDistance = backgroundStarFieldSize * 0.9;

            // Touch-specific controls for OrbitControls (remain for mobile)
            controls.touches = {
                ONE: THREE.TouchID.ROTATE,
                TWO: THREE.TouchID.DOLLY,
                THREE: THREE.TouchID.PAN
            };
            controls.zoomSpeed = 1.0;
            controls.rotateSpeed = 1.0;
            controls.panSpeed = 1.0;

            // Dynamic controls.target for "fly-through" zooming
            const updateControlsTarget = () => {
                const targetOffset = 1000; // Original target offset
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                controls.target.copy(camera.position).add(cameraDirection.multiplyScalar(targetOffset));
            };
            updateControlsTarget();
            controls.addEventListener('change', updateControlsTarget);

            // Create Multiple Galaxies
            createMultipleGalaxies();

            // Create Background Stars
            createBackgroundStars();

            // Create Cosmic Dust/Nebula layers
            createCosmicDustLayers();

            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function createMultipleGalaxies() {
            for (let i = 0; i < numberOfGalaxies; i++) {
                const x = (Math.random() - 0.5) * (sceneExtent - galaxyDistributionPadding * 2);
                const y = (Math.random() - 0.5) * (sceneExtent - galaxyDistributionPadding * 2);
                const z = (Math.random() - 0.5) * (sceneExtent - galaxyDistributionPadding * 2);

                const galaxyOptions = {
                    position: new THREE.Vector3(x, y, z),
                    armCount: Math.round(2 + Math.random() * 3),
                    rotationSpeed: (Math.random() * 0.0005) + 0.0002,
                    colorCentral: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                    colorOuter: new THREE.Color().setHSL(Math.random(), 0.6, 0.4),
                    diskColor: new THREE.Color().setHSL(Math.random(), 1.0, 0.5),
                    galaxyRadius: defaultGalaxyRadius * (0.8 + Math.random() * 0.4),
                    particleCount: Math.floor(defaultParticleCount * (0.8 + Math.random() * 0.4))
                };

                const newGalaxy = new Galaxy(galaxyOptions);
                newGalaxy.init();
                galaxies.push(newGalaxy);
            }
        }

        function createBackgroundStars() {
            const positions = new Float32Array(backgroundStarCount * 3);
            const sizes = new Float32Array(backgroundStarCount);
            const opacities = new Float32Array(backgroundStarCount);

            for (let i = 0; i < backgroundStarCount; i++) {
                const radius = (Math.pow(Math.random(), 2) * 0.5 + 0.5) * backgroundStarFieldSize;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);

                sizes[i] = backgroundStarMinSize + Math.random() * (backgroundStarMaxSize - backgroundStarMinSize);
                opacities[i] = 0.5 + Math.random() * 0.5;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: new THREE.TextureLoader().load('https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/examples/textures/sprites/spark1.png') },
                    time: { value: 0.0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute float opacity;
                    varying float vOpacity;
                    uniform float time;

                    void main() {
                        vOpacity = opacity * (0.7 + sin(position.x * 0.1 + time * ${backgroundStarTwinkleSpeed}) * 0.3);
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 200.0 / -mvPosition.z ); // Base size for laptops
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying float vOpacity;
                    void main() {
                        gl_FragColor = vec4( 1.0, 1.0, 1.0, vOpacity ) * texture2D( pointTexture, gl_PointCoord );
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            backgroundStars = new THREE.Points(geometry, material);
            scene.add(backgroundStars);
        }

        function createCosmicDustLayers() {
            nebulaLayersData.forEach(layer => {
                const geometry = new THREE.SphereGeometry(layer.radius, 32, 32); // Balanced segments
                const material = new THREE.MeshBasicMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending
                });
                const dustMesh = new THREE.Mesh(geometry, material);
                dustMesh.rotationSpeed = layer.rotationSpeed;
                cosmicDustLayers.push(dustMesh);
                scene.add(dustMesh);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update();
            
            galaxies.forEach(galaxy => {
                galaxy.update();
            });

            if(backgroundStars) {
                backgroundStars.material.uniforms.time.value += 1;
                backgroundStars.rotation.y += 0.000005;
                backgroundStars.rotation.x += 0.000002;
            }
            
            cosmicDustLayers.forEach(layer => {
                layer.rotation.y += layer.rotationSpeed;
                layer.rotation.x += layer.rotationSpeed * 0.5;
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = init;
    </script>
</body>
</html>